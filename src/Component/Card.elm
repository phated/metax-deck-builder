module Component.Card
    exposing
        ( Card(..)
        , decoder
        , toHtml
        , query
        , load
        , order
        )

{-| Component.Card represents an individual card.


# Types

@docs Card


# Build


# Encoders/Decoders

@docs decoder


# Views

@docs toHtml


# Query

@docs query, load


# Sorting

@docs order

-}

import Html exposing (Html)
import Json.Decode as Decode exposing (field, at, andThen, Decoder)
import Compare exposing (Comparator)
import GraphQl as Gql exposing (Value, Query, Anonymous, Request)
import Component.Card.UID as CardUID exposing (UID)
import Component.Card.Type as CardType exposing (Type)
import Component.Character as Character exposing (Character)
import Component.Event as Event exposing (Event)
import Component.Battle as Battle exposing (Battle)


{-| A full card.
-}
type Card
    = CharacterCard Character
    | EventCard Event
    | BattleCard Battle


{-| Decode a string into a Card.
-}
decoder : Decoder Card
decoder =
    field "type" CardType.decoder |> andThen cardFromType


map : (a -> b) -> a -> b
map mapper card =
    case card of
        CharacterCard card ->
            mapper card

        EventCard card ->
            mapper card

        BattleCard card ->
            mapper card


{-| Render a Card as an Html view.
-}
toHtml : Card -> Html msg
toHtml card =
    case card of
        CharacterCard card ->
            Character.toHtml card

        EventCard card ->
            Event.toHtml card

        BattleCard card ->
            Battle.toHtml card


{-| Generate a GraphQL query for a card by UID.
-}
query : UID -> Value Query
query uid =
    Gql.field "Card"
        |> Gql.withArgument "uid" (CardUID.toString uid |> Gql.string)
        |> Gql.withSelectors
            [ Gql.field "uid"
            , Gql.field "set"
            , Gql.field "number"
            , Gql.field "rarity"
            , Gql.field "mp"
            , Gql.field "type"
            , Gql.field "title"
            , Gql.field "subtitle"
            , Gql.field "trait"
                |> Gql.withSelectors
                    [ Gql.field "name"
                    ]
            , Gql.field "effect"
                |> Gql.withSelectors
                    [ Gql.field "symbol"
                    , Gql.field "text"
                    ]
            , Gql.field "stats"
                |> Gql.withSelectors
                    [ Gql.field "type"
                    , Gql.field "rank"
                    ]
            , Gql.field "imageUrl"
            , Gql.field "preview"
                |> Gql.withSelectors
                    [ Gql.field "previewer"
                    , Gql.field "previewUrl"
                    ]
            ]


{-| Fetch a Card using a query generated by query.
-}
load : Value Query -> Request Query Anonymous Card
load query =
    Gql.query
        "https://api.graph.cool/simple/v1/metaxdb"
        (Gql.object [ query ])
        (at [ "Card" ] decoder)


{-| Defines the sort order for a Card.
-}
order : Card -> Card -> Order
order wrappedCard1 wrappedCard2 =
    case ( wrappedCard1, wrappedCard2 ) of
        ( CharacterCard c1, CharacterCard c2 ) ->
            Compare.concat
                [ Compare.by .title
                , Compare.by (.text << .effect)
                ]
                c1
                c2

        ( _, _ ) ->
            LT



--
-- Internals - these might be pulled out
-- battleTypeOrder : Card -> Int
-- battleTypeOrder { card_type, stats } =
--     case card_type of
--         Battle ->
--             BattleType.toInt stats
--         Character ->
--             0
--         Event ->
--             0
{- Internals -}


cardFromType : Type -> Decoder Card
cardFromType cardType =
    case cardType of
        CardType.Character ->
            Decode.map CharacterCard Character.decoder

        CardType.Event ->
            Decode.map EventCard Event.decoder

        CardType.Battle ->
            Decode.map BattleCard Battle.decoder
