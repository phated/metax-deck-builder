module Component.Card
    exposing
        ( Card
        , decoder
        , toHtml
        , query
        , load
        , order
        )

{-| Component.Card represents an individual card.


# Types

@docs Card


# Build


# Encoders/Decoders

@docs decoder


# Views

@docs toHtml


# Query

@docs query, load


# Sorting

@docs order

-}

import Html exposing (Html, div, img, text, a)
import Html.Attributes exposing (class, src, href)
import Json.Decode exposing (int, string, nullable, field, maybe, at, Decoder)
import Json.Decode.Pipeline exposing (decode, required, custom, optional, optionalAt)
import Compare exposing (Comparator)
import GraphQl as Gql exposing (Value, Query, Anonymous, Request)
import Component.Card.UID as CardUID exposing (UID)
import Component.Card.Set as CardSet exposing (Set)
import Component.Card.Type as CardType exposing (Type(Character, Event, Battle))
import Component.Card.Effect as CardEffect exposing (Effect)
import Component.Card.Rarity as CardRarity exposing (Rarity)
import Component.Card.Preview as CardPreview exposing (Preview)
import Component.Card.StatList as CardStatList exposing (StatList)
import Component.Card.Stat exposing (Stat(Strength, Intelligence, Special))


{- TODO: Combine this with Stats/StatList? -}

import Data.BattleType as BattleType


{-| A full card.
-}
type alias Card =
    { uid : UID
    , set : Set
    , number : Int
    , rarity : Rarity
    , title : String
    , subtitle : Maybe String
    , card_type : Type
    , trait : String
    , mp : Int
    , effect : Effect
    , stats : StatList
    , image_url : String
    , preview : Maybe Preview
    }


{-| Decode a string into a Card.
-}
decoder : Decoder Card
decoder =
    decode Card
        |> required "uid" CardUID.decoder
        |> custom (field "set" CardSet.decoder)
        |> required "number" int
        |> required "rarity" CardRarity.decoder
        |> required "title" string
        |> optional "subtitle" (maybe string) Nothing
        |> custom (field "type" CardType.decoder)
        |> optionalAt [ "trait", "name" ] string ""
        |> required "mp" int
        |> custom (field "effect" CardEffect.decoder)
        |> custom (field "stats" CardStatList.decoder)
        |> required "imageUrl" string
        |> optional "preview" (maybe CardPreview.decoder) Nothing


{-| Render a Card as an Html view.
-}
toHtml : Card -> Html msg
toHtml card =
    div [ class "card-details" ]
        [ cardText card
        , cardStats card
        ]


{-| Generate a GraphQL query for a card by UID.
-}
query : UID -> Value Query
query uid =
    Gql.field "Card"
        |> Gql.withArgument "uid" (CardUID.toString uid |> Gql.string)
        |> Gql.withSelectors
            [ Gql.field "uid"
            , Gql.field "set"
            , Gql.field "number"
            , Gql.field "rarity"
            , Gql.field "mp"
            , Gql.field "type"
            , Gql.field "title"
            , Gql.field "subtitle"
            , Gql.field "trait"
                |> Gql.withSelectors
                    [ Gql.field "name"
                    ]
            , Gql.field "effect"
                |> Gql.withSelectors
                    [ Gql.field "symbol"
                    , Gql.field "text"
                    ]
            , Gql.field "stats"
                |> Gql.withSelectors
                    [ Gql.field "type"
                    , Gql.field "rank"
                    ]
            , Gql.field "imageUrl"
            , Gql.field "preview"
                |> Gql.withSelectors
                    [ Gql.field "previewer"
                    , Gql.field "previewUrl"
                    ]
            ]


{-| Fetch a Card using a query generated by query.
-}
load : Value Query -> Request Query Anonymous Card
load query =
    Gql.query
        "https://api.graph.cool/simple/v1/metaxdb"
        (Gql.object [ query ])
        (at [ "Card" ] decoder)


{-| Defines the sort order for a Card.
-}
order : Comparator Card
order =
    Compare.concat
        [ Compare.by (CardType.toInt << .card_type)
        , Compare.by battleTypeOrder
        , Compare.by .title
        , Compare.by (.text << .effect)
        ]



-- Internals - these might be pulled out


battleTypeOrder : Card -> Int
battleTypeOrder { card_type, stats } =
    case card_type of
        Battle ->
            BattleType.toInt stats

        Character ->
            0

        Event ->
            0


cardText : Card -> Html msg
cardText card =
    div [ class "card-text" ]
        [ div [ class "card-title" ]
            [ text card.title
            , text <| Maybe.withDefault "" <| Maybe.map (\s -> " - " ++ s) card.subtitle
            , text <| toBattleCardRank card
            ]
        , div [ class "card-trait" ] [ text <| cardTrait card.trait ]
        , CardEffect.toHtmlLazy card.effect
        ]


toRank : Stat -> Maybe Int -> Maybe Int
toRank stat rank =
    case stat of
        Strength rank ->
            Just rank

        Intelligence rank ->
            Just rank

        Special rank ->
            Just rank


toBattleCardRank : Card -> String
toBattleCardRank card =
    let
        rank =
            if card.card_type == Battle then
                List.foldr toRank Nothing card.stats
            else
                Nothing
    in
        case rank of
            Just rank ->
                " - Rank " ++ (toString rank)

            Nothing ->
                ""


cardTrait : String -> String
cardTrait trait =
    if trait == "" then
        ""
    else
        trait


cardStats : Card -> Html msg
cardStats card =
    div [ class "card-stats" ]
        (mpView card.mp :: CardStatList.toHtml card.stats)


mpView : Int -> Html msg
mpView stat =
    let
        prefix =
            if stat >= 0 then
                "+"
            else
                ""
    in
        div [ class "card-stat-mp" ] [ text ("MP" ++ ": " ++ prefix ++ toString stat) ]
