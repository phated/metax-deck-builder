module Component.CardList
    exposing
        ( CardList
        , empty
        , fromList
        , map
        , find
        , decoder
        , toHtml
        , query
        , load
        )

{-| Component.CardList represents a unique list of cards.


# Types

@docs CardList


# Build

@docs fromList, empty


# Helpers (TODO: Better name?)

@docs find, map


# Encoders/Decoders

@docs decoder


# Views

@docs toHtml


# Query

@docs query, load

-}

import Html exposing (Html, div)
import Html.Keyed as Keyed
import Html.Attributes exposing (id, class)
import Avl.Set as Set exposing (Set)
import GraphQl as Gql exposing (Value, Query, Anonymous, Request)
import Json.Decode exposing (Decoder, list, at, andThen, succeed)
import Util exposing (finder)
import Component.Card as Card exposing (Card)
import Component.Card.UID as UID


{-| A unique list of cards.
-}
type alias CardList =
    Set Card


{-| Creates an empty CardList.
-}
empty : CardList
empty =
    Set.empty


{-| Creates a CardList from a List of Cards.
-}
fromList : List Card -> CardList
fromList cards =
    Set.fromList Card.order cards


{-| Find the first Card in CardList that matches a predicate.
-}
find : (Card -> Bool) -> CardList -> Maybe Card
find predicate cards =
    Set.foldr (finder predicate) Nothing cards


{-| Map over a CardList to generate a list of transformed Cards.
-}
map : (Card -> a) -> CardList -> List a
map mapper cards =
    Set.foldr (mapper >> (::)) [] cards


{-| Decode a string into a CardList.
-}
decoder : Decoder CardList
decoder =
    list Card.decoder |> andThen (fromList >> succeed)


{-| Render a CardList as an Html view.
-}
toHtml : (Card -> Html msg) -> CardList -> Html msg
toHtml renderChild cards =
    let
        renderChildKeyed card =
            ( UID.toString card.uid, renderChild card )
    in
        Keyed.node "div" [ id "card-list-pane", class "pane list-item-grid" ] (map renderChildKeyed cards)


{-| Generate a GraphQl query for a CardList of all cards.
-}
query : Value Query
query =
    Gql.field "allCards"
        |> Gql.withSelectors
            [ Gql.field "uid"
            , Gql.field "set"
            , Gql.field "number"
            , Gql.field "rarity"
            , Gql.field "mp"
            , Gql.field "type"
            , Gql.field "title"
            , Gql.field "subtitle"
            , Gql.field "trait"
                |> Gql.withSelectors
                    [ Gql.field "name"
                    ]
            , Gql.field "effect"
                |> Gql.withSelectors
                    [ Gql.field "symbol"
                    , Gql.field "text"
                    ]
            , Gql.field "stats"
                |> Gql.withSelectors
                    [ Gql.field "type"
                    , Gql.field "rank"
                    ]
            , Gql.field "imageUrl"
            , Gql.field "image"
                |> Gql.withSelectors
                    [ Gql.field "original"
                    , Gql.field "large"
                    , Gql.field "medium"
                    , Gql.field "small"
                    , Gql.field "thumbnail"
                    ]
            , Gql.field "preview"
                |> Gql.withArgument "filter" (Gql.queryArgs [ ( "isActive", Gql.bool True ) ])
                |> Gql.withSelectors
                    [ Gql.field "previewer"
                    , Gql.field "previewUrl"
                    ]
            ]


{-| Fetch a CardList using a query generated by query.
-}
load : Value Query -> Request Query Anonymous CardList
load query =
    Gql.query
        "https://api.graph.cool/simple/v1/metaxdb"
        (Gql.object [ query ])
        (at [ "allCards" ] decoder)
