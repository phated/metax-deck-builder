module Component.CardList
    exposing
        ( CardList
        , empty
        , fromList
        , map
        , find
        , decoder
        , toList
        , query
        , load
        )

{-| Component.CardList represents a unique list of cards.


# Types

@docs CardList


# Build

@docs fromList, empty


# Helpers (TODO: Better name?)

@docs find, map


# Encoders/Decoders

@docs decoder


# Views

@docs toList


# Query

@docs query, load

-}

import Avl.Set as Set exposing (Set)
import GraphQl as Gql exposing (Value, Query, Anonymous, Request)
import Json.Decode exposing (Decoder, list, at, andThen, succeed)
import Compare exposing (concat, by, Comparator)
import Util exposing (finder)
import Data.BattleType as BattleType
import Component.Card as Card exposing (Card)
import Component.Card.Type as CardType exposing (Type(Battle, Character, Event))


{-| A unique list of cards.
-}
type alias CardList =
    Set Card


{-| Creates an empty CardList.
-}
empty : CardList
empty =
    Set.empty


{-| Creates a CardList from a List of Cards.
-}
fromList : List Card -> CardList
fromList cards =
    Set.fromList order cards


{-| Find the first Card in CardList that matches a predicate.
-}
find : (Card -> Bool) -> CardList -> Maybe Card
find predicate cards =
    Set.foldr (finder predicate) Nothing cards


{-| Map over a CardList to generate a list of transformed Cards.
-}
map : (Card -> a) -> CardList -> List a
map mapper cards =
    Set.foldr (mapper >> (::)) [] cards


{-| Decode a string into a CardList.
-}
decoder : Decoder CardList
decoder =
    list Card.decoder |> andThen (fromList >> succeed)


{-| Turn a CardList into a List of Cards.
-}
toList : CardList -> List Card
toList cards =
    Set.toList cards


{-| Generate a GraphQl query for a CardList of all cards.
-}
query : Value Query
query =
    Gql.field "allCards"
        |> Gql.withSelectors
            [ Gql.field "uid"
            , Gql.field "set"
            , Gql.field "number"
            , Gql.field "rarity"
            , Gql.field "mp"
            , Gql.field "type"
            , Gql.field "title"
            , Gql.field "subtitle"
            , Gql.field "trait"
                |> Gql.withSelectors
                    [ Gql.field "name"
                    ]
            , Gql.field "effect"
                |> Gql.withSelectors
                    [ Gql.field "symbol"
                    , Gql.field "text"
                    ]
            , Gql.field "stats"
                |> Gql.withSelectors
                    [ Gql.field "type"
                    , Gql.field "rank"
                    ]
            , Gql.field "imageUrl"
            , Gql.field "preview"
                |> Gql.withSelectors
                    [ Gql.field "previewer"
                    , Gql.field "previewUrl"
                    ]
            ]


{-| Fetch a CardList using a query generated by query.
-}
load : Value Query -> Request Query Anonymous CardList
load query =
    Gql.query
        "https://api.graph.cool/simple/v1/metaxdb"
        (Gql.object [ query ])
        (at [ "allCards" ] decoder)



-- Utils
-- TODO: Dedupe sorting


battleTypeOrder : Card -> Int
battleTypeOrder { card_type, stats } =
    case card_type of
        Battle ->
            BattleType.toInt stats

        Character ->
            0

        Event ->
            0


order : Comparator Card
order =
    concat
        [ by (CardType.toInt << .card_type)
        , by battleTypeOrder
        , by .title
        , by (.text << .effect)
        ]
